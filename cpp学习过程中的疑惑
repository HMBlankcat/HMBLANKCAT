Q1:如果有多个派生类同时虚继承一个类,会重复调用被继承类的构造函数吗
构造顺序：
首先按照基类中声明顺序，初始化所有的虚基类，然后再按照顺序初始化所有的非虚基类。如果有在构造函数中调用有参构造函数就调用有参构造函数，否则调用无参构造函数。
虚基类是由最底层的派生类初始化的，即可能在虚基类继承路径上每个派生类都有对虚基类的初始化，但是当一个类继承了虚基类时，由它控制对虚基类的初始化，如果它不进行初始化，会调用虚基类的无参构造函数进行初始化。（而不是其他基类，就算它的构造函数中有对虚基类的初始化）
析构的顺序和构造函数的顺序相反。
原理
但是虚继承是如何实现的呢？在网上查找资料后记录一下自己的理解（可能不是很准确，但是可能会帮助理解问题）：
学术的说：虚继承通过虚基类指针（占四个字节）和虚基类表（不占类的字节）实现。虚基类表中记录了虚基类与本类的偏移地址，虚基类指针指向虚基类表，通过偏移地址就找到了虚基类成员，从而实现虚继承。
可能有点难以理解，我的理解就是，派生类地址可能一般不是和基类在一起的，仅仅是通过构造函数等实现对基类成员的继承。而虚基类地址可能地址就在基类后面。
假设我们有基类A，虚基类B,C，以及B,C的派生类类D
每次我们创建D的时候先创建基类A的成员，然后通过需基类指针和虚基类表找到虚基类B的地址创建他特有的成员，然后再找到C的地址创建他特有的成员，这样就不会将A中的成员重复创建，实现了虚继承。
c++语言枚举常量的默认值为0.1.2.3.4.5.6.7.8...
定义const类型变量时必须初始化
符号常量的值在定义后不可以被修改
变量如果没有说明存储类型,那么默认就是auto
先定义指针变量,在给指针变量赋初值有三种情况:①p=&a;②p=p1 变量地址 ③赋空值0
