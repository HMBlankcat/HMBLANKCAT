指针数组
数据类型 *数组名[数组长度说明];
eg:int *pb[2];
int b[2][3];
pb[0]=b[0];
pb[1]=b[1];
......

＊＊二维数组与指针数组的区别 空间连续性不同
二维数组 连续空间 char name[5][9]={"gain","much","stronger","point","bye"};
指针数组 不一定连续空间char *name[5]={"gain","much","stronger","point","bye"};
所以指针数组可以省内存
连续空间 g a i n \0 NULL NULL NULL NULL
        s t r o n g e r \0
不一定连续空间 g a i n \0
	         s t r o n g e r \0
用指针数组不用担心char内存溢出的问题，不用考虑最长的字符串长度
一级指针：指针变量中存放目标变量的地址
P（指针变量）     i（整型变量）
＆i      ----->  5
一级指针   单级间接寻址

二级指针：指针变量中存放一级指针变量的地址
int **p与int *q[10]
指针数组明p是二级指针常量，q[i]是指针变量
如果执行p=q; 则p＋i是q[i]的地址

指针常量 常量指针
以＊为界，放在后面(指针常量)，指向不能修改，即使是同一个地址，放在前面（常量指针），内容(指向常量的值)不能修改
const int *cp和int const*cp等价

引用是一个别名，必须初始化，因为引用总是附属于某个实体
int someint=5;
int& rint=someint;//初始化

引用和指针很容易混淆：
①不存在空引用，因为引用必须连接到一块合法的内存
②一但引用被初始化为一个对象，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象
③引用必须在被创建时被初始化，指针可以在任何时间被初始化
          
动态内存分配
错误的数据定义：
in n,a[n]；静态存储分配：程序需在编译时就分配内存空间
动态分配内存的格式如下：
指针变量名＝new 类型名 (初值列表);
int *point;
point=new int(2);
    从自由存储区分配对象，然后用括号中的值初始化对象
    释放指针所指向的内存空间的格式为：
    delete 指针名；
    释放指针本身所指目标的内存空间，指针本身并没有撤销
    指针变成悬空指针，建议这时将指针置空（NULL）;

动态数组如何定义？
指针变量名＝new 类型名[下标表达式];
delete[]指向该数组的指针变量名
两式中的方括号必须配对使用
delete[]方括号中不需要填写数组元素数，创建时不能对数组元素进行初始化
下标表达式不是常量表达式！！！！！
动态数组的访问：
数组元素＝＝指针名[下标]；

float *cp[9][8]=new float[8][9][8];
定义三维数组
不是float ***cp;！！

冒泡排序 选择排序
顺序查找：关键字逐个比较，查找速度慢
折半查找（只能对有序表进行查找）
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
