第一章
c++特点：1.支持抽象数据类型 2.多态性 3.继承性
c++程序组成:由一个函数或多个函数构成,并且只有一个主函数main 是程序执行的入口
程序设计流程:定义要解决的问题-确定如何解决问题-编写程序-编译源代码-连接目标文件和库-调试-测试
2.1数据类型
基本：布尔型、整型、字符型、浮点型、空类型
复合：指针类型 数组类型 枚举类型 联合类型 结构类型 类类型
char：字符型数据通常占用一个字节存储空间
整数也可以隐式的转换成 bool 值：非 0的整数转换成 true,0 转换成 false。
float通常4个字节 double通常八个字节
没有void类型的对象
unsigned和signed只用来修饰char和int，signed可以省略。对于有符号和无符号的整型数据，它们所占的存储空间的大小相同，但它们的表数范围却不相同（对字符型意义相同）。
结构体：不同的数据类型构成的一种混合的数据结构
共用体：类似于结构体的一种构造类型，构成共同体的数据成员共用同一段内存单元
指针类型：指针类型变量用于存储另一变量的地址，而不能用来存放基本类型的数据，在内存中占据一个存储单元。
2.2变量与常量
变量特征：变量类型、变量名、变量值
命名：1.关键字不可 2.下划线开头的名字是保留给实现或者运行环境，用于特殊目的，在程序中欧冠不要采用这样的名字3.大小写区分
4.见名知意 5.维持统一的命名风格
typedef：为某种类型声明一个新名字，而不是定义一种新类型 typedef <已有类型名> <新类型名>
常量
字符常量：用单括号引起的一个字符
字符串常量：由一对双引号括起来的零个或多个字符序列
字符串可以写在多行上，不过在这种情况下必须用反斜线‘\’表示下一行字符是这一行字符的延续。
字符串常量实际上是一个字符数组，组成数组的字符除显示给出的外，还包括字符结尾处标识字符串结束的符号‘\0’，所以字符串“abc”实际上包含 4 个字符：‘a’、‘b’、‘c’和‘\0’。
整型常量：可以用十进制八进制或十六进制表示
十进制常量 ：一般占一个机器字长，是一个带正负号的常数（默认情况下为正数）。
八进制常量 ：由数字 0 开头，其后由若干 0-7 的数字组成，如 0378，0123 等。
十六进制常量：以 0x 或 0X 开头，其后由若干 0-9 的数字及 A-F（或小写 a-f）的字母组成，如 0x123，0x3ab。
浮点型常量：有小数表示法和指数表示法
如11.3   .2   2.3e10   -2.3E-1等等
枚举常量：
声明形式：enum <枚举名>{<枚举符表>};
枚举符可以有两种形式：<枚举符名>/<枚举符名>=<整型常量>
符号常量：定义形式：const <类型名> <符号常量名>=<表达式>[,...];
[]表示可选项，以下都采用这种标记
定义的符号常量必须初始化，一个符号常量可看做是一个只读变量
2.3运算符 表达式
(type)强制类型转换运算符  (int)x
流读取运算符>>表示流的输入，可以从cin输入流中读取字符；流插入运算符<<表示流的输出，可以向cout输出流插入字符
<iostream>运算符
dex：十进制 hex：十六进制 oct：八进制
setfill(c)设填充字符为c  setprecision(n)设显示小数精度为n位
setw（n）设域宽为n个字符   
<iomanip>头文件控制符
setiosflags(ios::fixed)固定的浮点显示
setiosflags(ios::scientific)指数表示
setiosflags(ios::left)左对齐
setiosflags(ios::right)右对齐
setiosflags(ios::skipws)忽略前导空白            ？
setiosflags(ios::uppercase)十六进制数大写输出
setiosflags(ios::lowercase)十六进制数小写输出
setprecision：设置数字精度；
fixed：浮点数设置成普通的小数显示；
scientific：浮点数用科学计数法。
setprecision设置的是整个数值的有效位数，而不是小数部分的有效位数。
uppercase：对于进制前缀、十六进制a-f和浮点数科学计数法的字母e，均显示大写字母；
nouppercase：对于进制前缀、十六进制a-f和浮点数科学计数法的字母e，均显示小写字母，为默认值；
setiosflags(ios::showpoin)显示小数点
setiosflags(ios::showpos)显示符号（正负号）
setiosflags(ios::showbase)指定在数值前输出进制（0八进制 0x或0X十六进制）

位运算：按位与＆：将两个运算量中的每一个位进行逻辑与操作0 0为0 0 1为0 1 1为1
eg：计算3＆5
3：00000011
5：00000101
3＆5：00000001
将某一位置0，其他位置不变

按位或｜：将两个运算量的每一个位进行逻辑或操作
3｜5：00000111

按位异或^:
计算071^521
071:00111001
052:00101010
071^051:00010011
若对应位相同则结果该位为0
若对应位不同则结果该位为1
用途：使特定位翻转（与0异或保持原值，与异或取反）
例如：要01111010低四位翻转：
01111010
(^)00001111
01110101

取反～：单目运算符，对一个二进制数按位取反
eg：025：0000000000010101
～025：1111111111101010

移位
左移运算（<<)
左移后 低位补0 高位舍弃
右移运算（>>)
右移后低位舍弃，高位：无符号数：补0，有符号数：补“符号位”

-8左移为0xf8
11111000－>11110000 0xf0
 10010000 -16
 11110000右移
 11111000

Q1:有 a、b、c、max 四个变量，求 a、b、c 中的最大值，并将结果放入 max 中。
A1:主要考查对条件表达式的理解和书写。答案为：max=a>b?(a>c?a:c):(b>c?b:c)。

Q2:求解下列各表达式的值（其中 x 的值为 100）。
(1) (a=1,b=2,c=3)
(2) 1|3<<5
(3) 'a'+3&&!0%1
(4) x%2？“odd”:” even”
A2: （1）逗号表达式的值是其最后一个表达式的值。答案为：3。
(2) <<运算符的优先级高于|运算符，所以先算 3<<5 结果为 96（二进制 1100000），然后与1 做按位与运算则结果为 97（二进制 1100001）。答案为：97。
(3) 参与本题的运算符，按优先级由高到低依次是：!运算符、算术运算符、逻辑运算符。'a'+3 时字符型首先隐式转换成整型然后相加结果为 100，!0%1 即 1%1 结果为 0，100&&0结果为 0。答案为：0。
(4) 算术表达式的优先级高于条件表达式，所以先算 x%2 结果为 0，0?”odd”:”even”结果为”even”。本题完成判断一个数是奇数还是偶数，若该数为奇数，则表达式的值为”odd”，为偶数，则表达式的值为”even”。答案为：”even”。

#include <iostream>
#include <iomanip>
Using namespace std;
void main()
{ 
 int a = 23;
 double b = 23.123456789;
 cout<<a<<'\t'<<b<<endl;
 cout<<setprecision(0)<<b<<endl
cout<<setiosflags(ios::fixed)<<setprecision(7)<<b<<endl;
 cout<<setiosflags(ios::scientific)<<b<<endl;
 cout<<setprecision(6);
 cout<<setiosflags(ios::showbase);
 cout<<hex<<a<<'\t'<<a<<endl;
 cout<<dec;
 cout<<setw(10)<<setfill('*')<<setiosflags(ios::left)<<a<<endl;
cout<<setfill(' ');
}
解答：
本题主要考查对格式化输入输出的掌握。
①本题主函数中第三行输出 a,b，’\t’为转义字符，其含义是跳过一个制表位。不设置输出宽度时，默认输出 6 位有效数字，超出部分四舍五入。所以该行输出为：23 23.1235。
② setprecision(n)设置显示精度，最少显示一位有效数字。如果不重新设置，则其保持效力，所以使用完后要还原为 6 位默认值。第四行中设置 setprecision(0)与 setprecision(1)
作用相同，结果显示一位有效数字即为：2e+001。
③ setiosflags(ios::fixed)为固定的浮点显示，其后跟 setprecision(n)表示小数点后显示精度为 n。所以第五行输出结果为：23.1234568。
④ setiosflags(ios::scientific)为指数显示，当其整数部分宽度大于设置的显示精度（默认为 6 位）时，以指数形式显示结果。否则根据设置的（或默认的）显示精度显示 n 位有效
数字。所以第六行输出结果为：23.12346。
⑤ setiosflags(ios::showbase)为指定在数值前输出进制。hex 置基数为 16，且该操作保持效力，所以使用完后应该恢复为默认值 10 进制。第九行输出结果为：0x17 0x17。
⑥setw(n) 设域宽为 n 个字符，setfill(c) 设填充字符为 c ，setiosflags(ios::left)为左对齐。第十一行输出结果为：23********。
答案为：
23 23.1235
2e+001
23.1234568
23.12346
0x17 0x17
23********



























