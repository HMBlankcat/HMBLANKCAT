第一章
c++特点：1.支持抽象数据类型 2.多态性 3.继承性
c++程序组成:由一个函数或多个函数构成,并且只有一个主函数main 是程序执行的入口
程序设计流程:定义要解决的问题-确定如何解决问题-编写程序-编译源代码-连接目标文件和库-调试-测试
2.1数据类型
基本：布尔型、整型、字符型、浮点型、空类型
复合：指针类型 数组类型 枚举类型 联合类型 结构类型 类类型
char：字符型数据通常占用一个字节存储空间
整数也可以隐式的转换成 bool 值：非 0的整数转换成 true,0 转换成 false。
float通常4个字节 double通常八个字节
没有void类型的对象
unsigned和signed只用来修饰char和int，signed可以省略。对于有符号和无符号的整型数据，它们所占的存储空间的大小相同，但它们的表数范围却不相同（对字符型意义相同）。
结构体：不同的数据类型构成的一种混合的数据结构
共用体：类似于结构体的一种构造类型，构成共同体的数据成员共用同一段内存单元
指针类型：指针类型变量用于存储另一变量的地址，而不能用来存放基本类型的数据，在内存中占据一个存储单元。
2.2变量与常量
变量特征：变量类型、变量名、变量值
命名：1.关键字不可 2.下划线开头的名字是保留给实现或者运行环境，用于特殊目的，在程序中欧冠不要采用这样的名字3.大小写区分
4.见名知意 5.维持统一的命名风格
typedef：为某种类型声明一个新名字，而不是定义一种新类型 typedef <已有类型名> <新类型名>
常量
字符常量：用单括号引起的一个字符
字符串常量：由一对双引号括起来的零个或多个字符序列
字符串可以写在多行上，不过在这种情况下必须用反斜线‘\’表示下一行字符是这一行字符的延续。
字符串常量实际上是一个字符数组，组成数组的字符除显示给出的外，还包括字符结尾处标识字符串结束的符号‘\0’，所以字符串“abc”实际上包含 4 个字符：‘a’、‘b’、‘c’和‘\0’。
整型常量：可以用十进制八进制或十六进制表示
十进制常量 ：一般占一个机器字长，是一个带正负号的常数（默认情况下为正数）。
八进制常量 ：由数字 0 开头，其后由若干 0-7 的数字组成，如 0378，0123 等。
十六进制常量：以 0x 或 0X 开头，其后由若干 0-9 的数字及 A-F（或小写 a-f）的字母组成，如 0x123，0x3ab。
浮点型常量：有小数表示法和指数表示法
如11.3   .2   2.3e10   -2.3E-1等等
枚举常量：
声明形式：enum <枚举名>{<枚举符表>};
枚举符可以有两种形式：<枚举符名>/<枚举符名>=<整型常量>
符号常量：定义形式：const <类型名> <符号常量名>=<表达式>[,...];
[]表示可选项，以下都采用这种标记
定义的符号常量必须初始化，一个符号常量可看做是一个只读变量
2.3运算符 表达式
(type)强制类型转换运算符  (int)x
流读取运算符>>表示流的输入，可以从cin输入流中读取字符；流插入运算符<<表示流的输出，可以向cout输出流插入字符
<iostream>运算符
dex：十进制 hex：十六进制 oct：八进制
setfill(c)设填充字符为c  setprecision(n)设显示小数精度为n位
setw（n）设域宽为n个字符   
<iomanip>头文件控制符
setiosflags(ios::fixed)固定的浮点显示
setiosflags(ios::scientific)指数表示
setiosflags(ios::left)左对齐
setiosflags(ios::right)右对齐
setiosflags(ios::skipws)忽略前导空白            ？
setiosflags(ios::uppercase)十六进制数大写输出
setiosflags(ios::lowercase)十六进制数小写输出
setprecision：设置数字精度；
fixed：浮点数设置成普通的小数显示；
scientific：浮点数用科学计数法。
setprecision设置的是整个数值的有效位数，而不是小数部分的有效位数。
uppercase：对于进制前缀、十六进制a-f和浮点数科学计数法的字母e，均显示大写字母；
nouppercase：对于进制前缀、十六进制a-f和浮点数科学计数法的字母e，均显示小写字母，为默认值；
setiosflags(ios::showpoin)显示小数点
setiosflags(ios::showpos)显示符号（正负号）
setiosflags(ios::showbase)指定在数值前输出进制（0八进制 0x或0X十六进制）

位运算：按位与＆：将两个运算量中的每一个位进行逻辑与操作0 0为0 0 1为0 1 1为1
eg：计算3＆5
3：00000011
5：00000101
3＆5：00000001
将某一位置0，其他位置不变

按位或｜：将两个运算量的每一个位进行逻辑或操作
3｜5：00000111

按位异或^:
计算071^521
071:00111001
052:00101010
071^051:00010011
若对应位相同则结果该位为0
若对应位不同则结果该位为1
用途：使特定位翻转（与0异或保持原值，与异或取反）
例如：要01111010低四位翻转：
01111010
(^)00001111
01110101

取反～：单目运算符，对一个二进制数按位取反
eg：025：0000000000010101
～025：1111111111101010

移位
左移运算（<<)
左移后 低位补0 高位舍弃
右移运算（>>)
右移后低位舍弃，高位：无符号数：补0，有符号数：补“符号位”

-8左移为0xf8
11111000－>11110000 0xf0
 10010000 -16
 11110000右移
 11111000

Q1:有 a、b、c、max 四个变量，求 a、b、c 中的最大值，并将结果放入 max 中。
A1:主要考查对条件表达式的理解和书写。答案为：max=a>b?(a>c?a:c):(b>c?b:c)。

Q2:求解下列各表达式的值（其中 x 的值为 100）。
(1) (a=1,b=2,c=3)
(2) 1|3<<5
(3) 'a'+3&&!0%1
(4) x%2？“odd”:” even”
A2: （1）逗号表达式的值是其最后一个表达式的值。答案为：3。
(2) <<运算符的优先级高于|运算符，所以先算 3<<5 结果为 96（二进制 1100000），然后与1 做按位与运算则结果为 97（二进制 1100001）。答案为：97。
(3) 参与本题的运算符，按优先级由高到低依次是：!运算符、算术运算符、逻辑运算符。'a'+3 时字符型首先隐式转换成整型然后相加结果为 100，!0%1 即 1%1 结果为 0，100&&0结果为 0。答案为：0。
(4) 算术表达式的优先级高于条件表达式，所以先算 x%2 结果为 0，0?”odd”:”even”结果为”even”。本题完成判断一个数是奇数还是偶数，若该数为奇数，则表达式的值为”odd”，为偶数，则表达式的值为”even”。答案为：”even”。

#include <iostream>
#include <iomanip>
Using namespace std;
void main()
{ 
 int a = 23;
 double b = 23.123456789;
 cout<<a<<'\t'<<b<<endl;
 cout<<setprecision(0)<<b<<endl
cout<<setiosflags(ios::fixed)<<setprecision(7)<<b<<endl;
 cout<<setiosflags(ios::scientific)<<b<<endl;
 cout<<setprecision(6);
 cout<<setiosflags(ios::showbase);
 cout<<hex<<a<<'\t'<<a<<endl;
 cout<<dec;
 cout<<setw(10)<<setfill('*')<<setiosflags(ios::left)<<a<<endl;
cout<<setfill(' ');
}
解答：
本题主要考查对格式化输入输出的掌握。
①本题主函数中第三行输出 a,b，’\t’为转义字符，其含义是跳过一个制表位。不设置输出宽度时，默认输出 6 位有效数字，超出部分四舍五入。所以该行输出为：23 23.1235。
② setprecision(n)设置显示精度，最少显示一位有效数字。如果不重新设置，则其保持效力，所以使用完后要还原为 6 位默认值。第四行中设置 setprecision(0)与 setprecision(1)
作用相同，结果显示一位有效数字即为：2e+001。
③ setiosflags(ios::fixed)为固定的浮点显示，其后跟 setprecision(n)表示小数点后显示精度为 n。所以第五行输出结果为：23.1234568。
④ setiosflags(ios::scientific)为指数显示，当其整数部分宽度大于设置的显示精度（默认为 6 位）时，以指数形式显示结果。否则根据设置的（或默认的）显示精度显示 n 位有效
数字。所以第六行输出结果为：23.12346。
⑤ setiosflags(ios::showbase)为指定在数值前输出进制。hex 置基数为 16，且该操作保持效力，所以使用完后应该恢复为默认值 10 进制。第九行输出结果为：0x17 0x17。
⑥setw(n) 设域宽为 n 个字符，setfill(c) 设填充字符为 c ，setiosflags(ios::left)为左对齐。第十一行输出结果为：23********。
答案为：
23 23.1235
2e+01
23.1234568
23.12346
0x17 0x17
23********
3.1顺序控制语句
常见的表达式语句：空语句、赋值语句、函数调用语句
空语句：指只有一个分号而没有表达式的语句，它不作任何操作和运算。格式为： ；
空语句被用在程序的语法上要求一条语句而逻辑上却不需要的时候。
连续输入多项数据时应该键入空白字符（空格、回车、tab）将相邻的两项数据分开
连续输出时cout不会在相邻数据项间加分隔符，为了增强现实效果可以通过控制符自定义（iomanip）
空语句和空复合语句{  }是等价的
3.2.2 switch 语句
格式：switch(<表达式>)
{
case <常量表达式 1>：<语句序列 1>
case <常量表达式 2>：<语句序列 2>
case <常量表达式 n>：<语句序列 n>
[default：<语句序列 n+1>]
}
注：switch中的<表达式>值只能是整型/字符型/枚举型表达式
switch 语句中，case 和其后的<常量表达式>间必须有空格否则会产生逻辑错误。
每个 case 分支语句结束后都要加一个 break 语句来结束 switch 语句。但在要表示一个范围，或描述一类对象时（如 A,B,C 都属于合格，D 属于不合格）有可能几条 case 分支语句后才有一个 break 语句。
do...while语句:格式： do
{
<语句>
}while(<条件表达式>)；
continue:结束当前正在执行的这一次循环（for、while、do…while），接着执行下一次循环。即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环语句的判定。
4.1数组
数组名是一个标识符,代表数组在内存中的起始地址.数组中各元素在内存中连续存储
定义数组时对其中全部或部分元素指定初始值,这成为数组的初始化
数组名[常量表达式]={值1,值2,....};
当初始化的元素比数组中的元素个数少时，则按顺序对前一部分元素赋初值，其余元素自动初始化为 0 或空字符‘\0’（对字符数组）；当初始化的元素超过数组元素个数时，编译器会报错。 
对字符数组进行初始化可以对每个数组元素一一赋初值,也可以将一个字符串直接赋值给一个数组.但要注意数组长度除了包含字符串中个数还包含一个'\0'字符
通过 sizeof(数组名)/sizeof(数组类型)来求得实际的数组长度。
二维数组存放"先行后列"
对二维数组的初始化主要有两种形式：
第一、 数值按行用花括号分组对二维数组初始化。
第二、 所有数值按顺序在一个花括号中给出。
对以上两种形式，如果没有给出所有数组元素，则剩余元素自动初始化为 0。
若在一个花括号中对所有元素赋初值或者按行用花括号分组而组内元素部分或全部赋值，则可以缺省第一维的长度，但是[]不能省略，并且在任何情况下，二维数组第二维的长度均不可省略。
**数组定义中数组长度不能指定为除 const 变量以外的变量
为字符数组赋值可以直接从键盘键入一个字符串/用strcpy函数将一个字符串赋值到该字符数组或者用循环语句逐个为字符数组元素赋值.
不能直接将一个数组赋值给另一个数组
5.1函数
函数类型 函数名 (形参列表)
{
    函数体
};
任何情况下不能在一个函数中定义另一个函数.
函数原型:编译器可以对函数调用进行检查
格式:函数类型 函数名(形参列表);
值传递:形参改变不影响实参,生成实际参数值的副本并传递给被调用函数的形式参数
引用传递:是将形参作为实参的别名,所以通过形参可以直接访问实参数据,对形参值的改变就是对实参值的改变
引用传递需在定义形式参数时在形参前加引用符"&";
地址传递:地址传递是将实参的地址传递给形参,所以对形参所指地址中的内容进行修改,也会使实参值发生改变
需将形式参数的类型定义为指针类型 *

函数调用时实参与形参按照从左到右顺序匹配，当实参全部匹配而形参还有剩余时，则剩下的形参采用默认值。在对默认值进行定义时应该从右向左定义，在一个没有默认值的参数的左边又出现有默认值的参数是错误的。默认参数应在函数名首次出现时定义。

定义内联函数时在函数定义前加关键字 inline。
内联函数适用于经常使用的小函数。对于内联函数的函数体有一些限制：
①内联函数中不能含有任何循环以及 switch 和 goto 语句；
②内联函数中不能说明数组；
③递归函数（自己调用自己的函数）不能定义为内联函数。





















































