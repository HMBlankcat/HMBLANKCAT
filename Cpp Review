第一章
c++特点：1.支持抽象数据类型 2.多态性 3.继承性
c++程序组成:由一个函数或多个函数构成,并且只有一个主函数main 是程序执行的入口
程序设计流程:定义要解决的问题-确定如何解决问题-编写程序-编译源代码-连接目标文件和库-调试-测试
2.1数据类型
基本：布尔型、整型、字符型、浮点型、空类型
复合：指针类型 数组类型 枚举类型 联合类型 结构类型 类类型
char：字符型数据通常占用一个字节存储空间
整数也可以隐式的转换成 bool 值：非 0的整数转换成 true,0 转换成 false。
float通常4个字节 double通常八个字节
没有void类型的对象
unsigned和signed只用来修饰char和int，signed可以省略。对于有符号和无符号的整型数据，它们所占的存储空间的大小相同，但它们的表数范围却不相同（对字符型意义相同）。
结构体：不同的数据类型构成的一种混合的数据结构
共用体：类似于结构体的一种构造类型，构成共同体的数据成员共用同一段内存单元
指针类型：指针类型变量用于存储另一变量的地址，而不能用来存放基本类型的数据，在内存中占据一个存储单元。
2.2变量与常量
变量特征：变量类型、变量名、变量值
命名：1.关键字不可 2.下划线开头的名字是保留给实现或者运行环境，用于特殊目的，在程序中欧冠不要采用这样的名字3.大小写区分
4.见名知意 5.维持统一的命名风格
typedef：为某种类型声明一个新名字，而不是定义一种新类型 typedef <已有类型名> <新类型名>
常量
字符常量：用单括号引起的一个字符
字符串常量：由一对双引号括起来的零个或多个字符序列
字符串可以写在多行上，不过在这种情况下必须用反斜线‘\’表示下一行字符是这一行字符的延续。
字符串常量实际上是一个字符数组，组成数组的字符除显示给出的外，还包括字符结尾处标识字符串结束的符号‘\0’，所以字符串“abc”实际上包含 4 个字符：‘a’、‘b’、‘c’和‘\0’。
整型常量：可以用十进制八进制或十六进制表示
十进制常量 ：一般占一个机器字长，是一个带正负号的常数（默认情况下为正数）。
八进制常量 ：由数字 0 开头，其后由若干 0-7 的数字组成，如 0378，0123 等。
十六进制常量：以 0x 或 0X 开头，其后由若干 0-9 的数字及 A-F（或小写 a-f）的字母组成，如 0x123，0x3ab。
浮点型常量：有小数表示法和指数表示法
如11.3   .2   2.3e10   -2.3E-1等等
枚举常量：
声明形式：enum <枚举名>{<枚举符表>};
枚举符可以有两种形式：<枚举符名>/<枚举符名>=<整型常量>
符号常量：定义形式：const <类型名> <符号常量名>=<表达式>[,...];
[]表示可选项，以下都采用这种标记
定义的符号常量必须初始化，一个符号常量可看做是一个只读变量
2.3运算符 表达式
(type)强制类型转换运算符  (int)x
流读取运算符>>表示流的输入，可以从cin输入流中读取字符；流插入运算符<<表示流的输出，可以向cout输出流插入字符
<iostream>运算符
dex：十进制 hex：十六进制 oct：八进制
setfill(c)设填充字符为c  setprecision(n)设显示小数精度为n位
setw（n）设域宽为n个字符   
<iomanip>头文件控制符
setiosflags(ios::fixed)固定的浮点显示
setiosflags(ios::scientific)指数表示
setiosflags(ios::left)左对齐
setiosflags(ios::right)右对齐
setiosflags(ios::skipws)忽略前导空白            ？
setiosflags(ios::uppercase)十六进制数大写输出
setiosflags(ios::lowercase)十六进制数小写输出
setprecision：设置数字精度；
fixed：浮点数设置成普通的小数显示；
scientific：浮点数用科学计数法。
setprecision设置的是整个数值的有效位数，而不是小数部分的有效位数。
uppercase：对于进制前缀、十六进制a-f和浮点数科学计数法的字母e，均显示大写字母；
nouppercase：对于进制前缀、十六进制a-f和浮点数科学计数法的字母e，均显示小写字母，为默认值；
setiosflags(ios::showpoin)显示小数点
setiosflags(ios::showpos)显示符号（正负号）
setiosflags(ios::showbase)指定在数值前输出进制（0八进制 0x或0X十六进制）

位运算：按位与＆：将两个运算量中的每一个位进行逻辑与操作0 0为0 0 1为0 1 1为1
eg：计算3＆5
3：00000011
5：00000101
3＆5：00000001
将某一位置0，其他位置不变

按位或｜：将两个运算量的每一个位进行逻辑或操作
3｜5：00000111

按位异或^:
计算071^521
071:00111001
052:00101010
071^051:00010011
若对应位相同则结果该位为0
若对应位不同则结果该位为1
用途：使特定位翻转（与0异或保持原值，与异或取反）
例如：要01111010低四位翻转：
01111010
(^)00001111
01110101

取反～：单目运算符，对一个二进制数按位取反
eg：025：0000000000010101
～025：1111111111101010

移位
左移运算（<<)
左移后 低位补0 高位舍弃
右移运算（>>)
右移后低位舍弃，高位：无符号数：补0，有符号数：补“符号位”

-8左移为0xf8
11111000－>11110000 0xf0
 10010000 -16
 11110000右移
 11111000

Q1:有 a、b、c、max 四个变量，求 a、b、c 中的最大值，并将结果放入 max 中。
A1:主要考查对条件表达式的理解和书写。答案为：max=a>b?(a>c?a:c):(b>c?b:c)。

Q2:求解下列各表达式的值（其中 x 的值为 100）。
(1) (a=1,b=2,c=3)
(2) 1|3<<5
(3) 'a'+3&&!0%1
(4) x%2？“odd”:” even”
A2: （1）逗号表达式的值是其最后一个表达式的值。答案为：3。
(2) <<运算符的优先级高于|运算符，所以先算 3<<5 结果为 96（二进制 1100000），然后与1 做按位与运算则结果为 97（二进制 1100001）。答案为：97。
(3) 参与本题的运算符，按优先级由高到低依次是：!运算符、算术运算符、逻辑运算符。'a'+3 时字符型首先隐式转换成整型然后相加结果为 100，!0%1 即 1%1 结果为 0，100&&0结果为 0。答案为：0。
(4) 算术表达式的优先级高于条件表达式，所以先算 x%2 结果为 0，0?”odd”:”even”结果为”even”。本题完成判断一个数是奇数还是偶数，若该数为奇数，则表达式的值为”odd”，为偶数，则表达式的值为”even”。答案为：”even”。

#include <iostream>
#include <iomanip>
Using namespace std;
void main()
{ 
 int a = 23;
 double b = 23.123456789;
 cout<<a<<'\t'<<b<<endl;
 cout<<setprecision(0)<<b<<endl
cout<<setiosflags(ios::fixed)<<setprecision(7)<<b<<endl;
 cout<<setiosflags(ios::scientific)<<b<<endl;
 cout<<setprecision(6);
 cout<<setiosflags(ios::showbase);
 cout<<hex<<a<<'\t'<<a<<endl;
 cout<<dec;
 cout<<setw(10)<<setfill('*')<<setiosflags(ios::left)<<a<<endl;
cout<<setfill(' ');
}
解答：
本题主要考查对格式化输入输出的掌握。
①本题主函数中第三行输出 a,b，’\t’为转义字符，其含义是跳过一个制表位。不设置输出宽度时，默认输出 6 位有效数字，超出部分四舍五入。所以该行输出为：23 23.1235。
② setprecision(n)设置显示精度，最少显示一位有效数字。如果不重新设置，则其保持效力，所以使用完后要还原为 6 位默认值。第四行中设置 setprecision(0)与 setprecision(1)
作用相同，结果显示一位有效数字即为：2e+001。
③ setiosflags(ios::fixed)为固定的浮点显示，其后跟 setprecision(n)表示小数点后显示精度为 n。所以第五行输出结果为：23.1234568。
④ setiosflags(ios::scientific)为指数显示，当其整数部分宽度大于设置的显示精度（默认为 6 位）时，以指数形式显示结果。否则根据设置的（或默认的）显示精度显示 n 位有效
数字。所以第六行输出结果为：23.12346。
⑤ setiosflags(ios::showbase)为指定在数值前输出进制。hex 置基数为 16，且该操作保持效力，所以使用完后应该恢复为默认值 10 进制。第九行输出结果为：0x17 0x17。
⑥setw(n) 设域宽为 n 个字符，setfill(c) 设填充字符为 c ，setiosflags(ios::left)为左对齐。第十一行输出结果为：23********。
答案为：
23 23.1235
2e+01
23.1234568
23.12346
0x17 0x17
23********
3.1顺序控制语句
常见的表达式语句：空语句、赋值语句、函数调用语句
空语句：指只有一个分号而没有表达式的语句，它不作任何操作和运算。格式为： ；
空语句被用在程序的语法上要求一条语句而逻辑上却不需要的时候。
连续输入多项数据时应该键入空白字符（空格、回车、tab）将相邻的两项数据分开
连续输出时cout不会在相邻数据项间加分隔符，为了增强现实效果可以通过控制符自定义（iomanip）
空语句和空复合语句{  }是等价的
3.2.2 switch 语句
格式：switch(<表达式>)
{
case <常量表达式 1>：<语句序列 1>
case <常量表达式 2>：<语句序列 2>
case <常量表达式 n>：<语句序列 n>
[default：<语句序列 n+1>]
}
注：switch中的<表达式>值只能是整型/字符型/枚举型表达式
switch 语句中，case 和其后的<常量表达式>间必须有空格否则会产生逻辑错误。
每个 case 分支语句结束后都要加一个 break 语句来结束 switch 语句。但在要表示一个范围，或描述一类对象时（如 A,B,C 都属于合格，D 属于不合格）有可能几条 case 分支语句后才有一个 break 语句。
do...while语句:格式： do
{
<语句>
}while(<条件表达式>)；
continue:结束当前正在执行的这一次循环（for、while、do…while），接着执行下一次循环。即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环语句的判定。
4.1数组
数组名是一个标识符,代表数组在内存中的起始地址.数组中各元素在内存中连续存储
定义数组时对其中全部或部分元素指定初始值,这成为数组的初始化
数组名[常量表达式]={值1,值2,....};
当初始化的元素比数组中的元素个数少时，则按顺序对前一部分元素赋初值，其余元素自动初始化为 0 或空字符‘\0’（对字符数组）；当初始化的元素超过数组元素个数时，编译器会报错。 
对字符数组进行初始化可以对每个数组元素一一赋初值,也可以将一个字符串直接赋值给一个数组.但要注意数组长度除了包含字符串中个数还包含一个'\0'字符
通过 sizeof(数组名)/sizeof(数组类型)来求得实际的数组长度。
二维数组存放"先行后列"
对二维数组的初始化主要有两种形式：
第一、 数值按行用花括号分组对二维数组初始化。
第二、 所有数值按顺序在一个花括号中给出。
对以上两种形式，如果没有给出所有数组元素，则剩余元素自动初始化为 0。
若在一个花括号中对所有元素赋初值或者按行用花括号分组而组内元素部分或全部赋值，则可以缺省第一维的长度，但是[]不能省略，并且在任何情况下，二维数组第二维的长度均不可省略。
**数组定义中数组长度不能指定为除 const 变量以外的变量
为字符数组赋值可以直接从键盘键入一个字符串/用strcpy函数将一个字符串赋值到该字符数组或者用循环语句逐个为字符数组元素赋值.
不能直接将一个数组赋值给另一个数组
5.1函数
函数类型 函数名 (形参列表)
{
    函数体
};
任何情况下不能在一个函数中定义另一个函数.
函数原型:编译器可以对函数调用进行检查
格式:函数类型 函数名(形参列表);
值传递:形参改变不影响实参,生成实际参数值的副本并传递给被调用函数的形式参数
引用传递:是将形参作为实参的别名,所以通过形参可以直接访问实参数据,对形参值的改变就是对实参值的改变
引用传递需在定义形式参数时在形参前加引用符"&";
地址传递:地址传递是将实参的地址传递给形参,所以对形参所指地址中的内容进行修改,也会使实参值发生改变
需将形式参数的类型定义为指针类型 *

函数调用时实参与形参按照从左到右顺序匹配，当实参全部匹配而形参还有剩余时，则剩下的形参采用默认值。在对默认值进行定义时应该从右向左定义，在一个没有默认值的参数的左边又出现有默认值的参数是错误的。默认参数应在函数名首次出现时定义。

定义内联函数时在函数定义前加关键字 inline。
内联函数适用于经常使用的小函数。对于内联函数的函数体有一些限制：
①内联函数中不能含有任何循环以及 switch 和 goto 语句；
②内联函数中不能说明数组；
③递归函数（自己调用自己的函数）不能定义为内联函数。

5.5函数重载
函数调用是根据参数的类型 个数决定具体调用哪个函数
首先进行参数完全匹配,无法完全匹配时按隐式数据类型转换的方向进行匹配,仍无法匹配就报错
函数重载解析与函数定义或声明的顺序无关
当多个函数参数个数及类型均相同,只有函数返回值类型不同时则报错

5.6数组参数
数组作为函数的参数时,传递的是数组中第0个元素的地址(指针),因此在被调用函数时对形参数组值的改变将被应用到实参数组
数组长度不是参数类型的一部分，函数不知道传递给它的数组的实际长度，当编译器对实参类型进行参数类型检查时并不检查数组的长度，因此在定义形参时可以只写数组名[]
有时在被调用函数中需要知道数组长度,可以采用下面两种方式传递数组长度信息:
① 提供一个含有数组长度的额外参数，即定义一个用于存放数组长度的形参。
② 将被调用函数的形式参数声明为数组的引用，当形式参数是一个数组类型的引用时数组长度成为形式参数类型的一部分，编译器会检查数组实参的长度与在函数形参类型中指定的长度是否匹配。

5.7变量的作用域与生存期

5.7.1局部变量与全局变量
程序的内存区域:
代码区,存放程雪的代码,即程序中各个函数的代码块
全局数据区:存放程序全局数据和静态数据
堆区:存放程序的动态数据
栈区:存放程序的局部数据(各个函数中的)
局部变量:在一个函数内部说明的
全局变量:在函数外部定义的变量
*****①在同一文件中允许外部变量和内部变量同名.内部变量的作用域内,外部变量将被屏蔽而不起作用
外部变量说明的一般形式:
extern 数据类型 外部变量[,外部变量2......];
外部变量的定义必须在所有函数之外并且只能定义一次,外部变量的说明出现在要使用该外部变量的函数内,而且可以出现多次
如果定义点之前的函数需要引用这些外部变量时，需要在函数内对被引用的外部变量进行说明。
5.7.2静态变量
静态局部变量:定义格式:static 数据类型 内部变量表;
定义但不初始化,则自动赋"0"(整型和实型)或'\0'(字符型);且每次调用他们所在的函数时不再重新赋初值,只保留上次调用结束时的值
静态全局变量
全局变量前加一个static,使该变量只在这个源文件中可用
对组成该程序的其它源文件是无效的

5.7.3生命期
静态生命期:与程序运行期相同
局部生命期:在函数内声明的变量或者是块中声明的变量具有局部生命期.
动态生命期:由程序中特定的函数调用操作符(new和delete)来创建和释放

例题:
函数在被调用之前必须先声明或定义√

strcpy()函数：是将一个字符串复制到另一块空间地址中 的函数，‘\0’是停止拷贝的终止条件，同时也会将 '\0' 也复制到目标空间。
char* strcpy(char* destination,const char* source);
1. 函数的参数：

char* destination---------目标字符串的首地址
const char* source------源地址：被复制的字符串的首地址，用const修饰，避免修改掉被拷贝的字符串
   2.函数的返回值类型：
char*：返回的是目标字符串的首地址 
1.源字符必须以 '\0'结束：
2.目标空间必须足够大，以确保能放源字符串
3.目标空间必须可变

strcmp
        比较两个字符串
 int strcmp( const char *string1, const char *string2 );
返回一个整数 
第一个字符串大于第二个字符串，则返回大于0的数字
第一个字符串等于第二个字符串，则返回0
第一个字符串小于第二个字符串，则返回小于0的数字
strcmp是比较字符串中对应位置上的字符大小（ASC II码值大小），如果相同，就比较下一对，直到不同或者都遇到'\0'。

---------------以下是左值 右值------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q1:#include <iostream>
using namespace std;
void fun1(const double& i)
{
cout<<i<<endl;
}
void fun2(double &j)
{
cout<<j<<endl;
}
void fun3(double k)
{
cout<<k<<endl;
}
void main()
{
fun1('a');
fun2('a');
fun3('a');
}
(a)97 (b)97 (c)a (d)程序出错，无法运行。
 97 a a
 97 97 a
A1:解答：
文字量、常量和需要类型转换的参数都可以传递给 const&参数，但不能传递给非 const 的引用参数。也就是说对非 const 引用参数不允许做类型转换。本题中对于函数 fun1 以及 fun3
在调用时参数都发生了隐形数据类型转换，而对于函数 fun2 它的参数为非 const 的引用参数，不允许作类型转换，所以对 fun2 的调用出错。因此程序出错无法运行。答案为：d。
?
Q2:***不能传递给非 const 的引用参数 What mean?
A2:字符在cpp中被看做字面常量,是一个指针无法直接改变的量,如果用double i这样的方式是创建了一个字面量的副本而没有改变原地址
const &这个新的指向字面量的指针也无法改变这块地址的值,但如果用一个非const引用意味着创建了一个能改变这个地址的值的方法
这样的行为是不被允许的,但是char a='a';  fun2(a);这个方法是可以的

eg:
#include<iostream>
int function(int &a)
{
  return a;
}
int main()
{
  int a = 5;
  function(a);           
  function(1);//这一句会报错
}
报错如下：
无法将参数1从Int转换为“int &”，非常量引用的初始值必须为左值
这里的左值，可以理解为在内存中有具体的地址的变量，而不是一个短暂的临时变量。
这个左右，可以理解为，在赋值号“=” 的左边，为左值，在等号右边，为右值，但这个左右并不是绝对的。
在第一个例子里，function(int a)的参数为实参，如果传入一个1，函数会创建一个有地址的局部变量a，对a进行赋值，
让 a= 1，这里的a是一个左值，所以程序能正确运行，但在第二个例子里，
function(int &a)的参数为一个地址，function会根据这个地址去取对应的值，但是我们传入的参数是数字1，这个1显然不是左值，
因为它不是变量，没有地址，function根据地址找不到对应的变量，自然会报错。

从等号的左边到右边的答案依次是：

int a = 10; // a左值，10右值
int c = a;  // c左值，a左值
std::string s1 = "Hello"; // s1左值，"Hello"右值
std::string s2 = "World"; // s2左值，"World"右值
std::string s3 = s1 + s2; // s3左值，s1 + s2右值
值得注意的是第二行和第五行，int c = a，由于两边都是变量，都有其存储空间，所以都是左值
但是第五行里，s1和s2都是左值，都有其存储空间，但是s1 + s2就不是左值了，因为相加得到的结果是一个临时变量，会被赋给s3。


左值引用与右值引用
左值引用，顾名思义就是对左值变量的引用，右值引用同理
int &a = 10; // 报错，因为无法创建一个左值的引用指向一个右值
int& GetValue(int& n)
{
    return 10; // 报错，返回的不是左值引用
}
int& GetValue(int& n)
{
    static int a = 10;
    return a; // 正确，a是左值，返回的是左值引用
}
注意，通过关键字const，我们可以实现如下的功能
const int &a = 10; //正确
这一行代码实际上相当于，这也就是const特殊的地方：
int temp = 10;
const int &a = temp;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



Q2:例题 12：写一个函数，它以一个名字作为命令行参数，打印输出“hello，name”（其中 name
为输入命令行参数）。
A2:解答：
本程序主要考查对命令行参数的理解及使用。
说明：
void main(int argc,char* argv[]){…}
即是说，除按通常的那种无参方式来使用 main 函数外，如果需要的话，main 函数还可
带有两个上述格式以及数据类型的形式参数。
main 带有形式参数时，其对应实参值由用户在执行该程序时指定，而后通过操作系统
将它们传递给 main 函数。main 函数所含两个参数的含义如下：
argc-----第一参数，记录命令行参数的个数（其值为实际命令行参数的个数加 1）；
argv-----第二参数，为字符串数组，存放执行程序名以及各实际命令行参数。各数组元素
的含义为：
argv[0]：本执行程序的文件名
argv[1]：第 1 个实际命令行参数（如果有）；
…
argv[argc-1]：第 argc-1 个实际命令行参数。
在 vc6.0 开发环境下设置命令行参数方法如下：
project→settings…→debug→”program arguments:”中，输入以空格分隔的各参数。
在命令提示符环境中，可通过如下形式运行程序：
程序文件名 参数 1 …
参数之间用空格隔开。
参考程序为：
#include <iostream>
using namespace std;
void main(int argc,char* argv[])
{
cout<<"hello,"<<argv[1]<<endl;
}



------------------------------------------------------------------------------------------------------------
例题 15：打印某一年的年历。
解答：
关于本题的编程细节请参见程序中的注释。
参考程序如下：
#include <iostream>
#include <iomanip>
using namespace std;
int FirstDayOfYear(int y);
int DaysOfMonth(int m);
void PrintMonth(int m);
void PrintHead(int m);
bool IsLeapYear(int y);
int weekDay;
int year;
void main()
{
cerr<<"请输入您想要打印的年份:\n";
cin>>year;
if(year<1900)
{
cerr<<"年份不能小于 1900。\n";
return;
}
weekDay=FirstDayOfYear(year);//一年的第一天星期几
//打印年标题
cout<<"\n\n\n\n\n "<<year<<" 年日历\n";
cout<<"\n ===================================================";
//打印每个月
for(int i=1;i<=12;i++)
PrintMonth(i);
cout<<endl;
}
//某个月打印函数
void PrintMonth(int m)
{
PrintHead(m); //打印月标题
int days=DaysOfMonth(m); //该月的天数
for(int i=1;i<=days;i++)
{
cout<<setw(6)<<i;
weekDay=(weekDay+1)%7;
if(weekDay==0) //打印下一天时判断是否换行
{
cout<<endl;
cout<<" ";//行首空格
}
}
}
//打印月标题
void PrintHead(int m)
{
cout<<"\n\n"<<setw(6)<<m<<"月 日 一 二 三 四 五 六
\n";
cout<<" ";
for(int i=0;i<weekDay;i++)
cout<<" ";
}
//判断某月天数的函数
int DaysOfMonth(int m)
{
switch(m){
case 1:
case 3:
case 5:
case 7:
case 8:
case 10:
case 12:return 31;
case 4:
case 6:
case 9:
case 11:return 30;
case 2:if(IsLeapYear(year))
 return 29;
 else
 return 28;
}
return 0;
}
//判断是否为闰年
bool IsLeapYear(int y)
{
return((y%4==0&&y%100!=0)||year%400==0);
}
//判断某年的第一天
//因为每年都是 52 个整星期多一天，因此 n 年多出的天数还是 n 天，
//再加上 1900 年到 year 年间因闰年多出来的天数，
//再加上 1900 年元旦的星期序号 1 与 7 取模便得出是第几天。由于 2000 年正好是闰年，所
//以可以计算到 2099 年。
int FirstDayOfYear(int y)
{
int n=y-1900;
n=n+(n-1)/4+1;
n=n%7;
return n;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------







































