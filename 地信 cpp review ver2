十进制数转换为R进制数：除r取余，自下而上法
十进制小数转换为R进制小数：乘r取整，自上而下
十进制转换二进制：除二取余算整数，乘2取整算小数
位（bit）度量数据的最小单位
bit B K M G T
1B＝8bit，剩下均为1024
浮点数构成：阶码和尾数
阶码是指数，尾数是纯小数
正数的原码反码补码都相同
ASCII码：A-Z 65-90
a－z 97－122
0－9 48－57
计算机组成：运算器、存储器、控制器、输入和输出设备
指令和数据用二进制码表示，同等地位存放于存储器内，并可按地址寻访
指令在存储器内按顺序存放，通常顺序执行，按下可改变执行顺序
算法特性：有穷性，确定性（每一个步骤都必须有确切的定义，不能有歧义），
输入（一个算法内有0或多个输入），输出（一个算法内有1或多个输出），有效性（）每一个步骤应当能有效的执行）

程序设计的基本步骤
需求分析－算法设计－画流程图－编写代码－上机调试

长整型整数以L或l结尾
无符号整数以u或U结尾，以UL或LU结尾可表示无符号长整型整数
单引号引起来的单个字符是字符型常量，'a'占一个字节，存放'a' 值为0x61
双引号引起来的若干个字符是字符串常量“a”占两个字节，存放'a'和'\0'，值为0x6100

标识符常量：用const给文字常量起的名字（标识符），也称为常变量
常变量只能在声明时进行初始化，初始化后不允许再被赋值

cin自动跳过输入的空白字符（制表符 回车 空格）

case之后可以接常量数值，字符，枚举类型常量
case之后不能接变量或者
case之后不能接实型数或带有实数的常量表达式

 错误的例子：先定义，后整体赋值
 //错误1
 int a[6]；
 a={0,1,2,3,4,5};
 对数组的访问指的是对数组元素的访问
 不能直接将数组名作为访问对象；
 在放弃初始化方法后，必须对每一个元素逐个赋值。

数组不能整体访问，只能访问数组元素

字符数组可以当作整体通过操作数组名来处理
注意：如果结尾没有加'\0'就不能这样操作。而且其他类型数组不能访问数组名。

只有字符数组允许整体输入和输出
以数组名输出时，数组如果没有结束符，会导致输出错误

以数组名输入时，系统会自动添加结束符，以字符串的方式存储数组
char name[5];
cin>>name;
运行时输入数据：hust(回车)
存储为 h u s t \0
 以数组名输入时，系统会自动添加结束符，以字符串的方式存储数组

用"cin>>数组名"的形式输入时，遇到空格，Tab键或回车键就表示输入结束；
 因此，输入单个字符串时，其中不能有空格


 cin.getline(字符数组名, 接受字符的最大个数n, 指定结束符)
 将输入的字符放入字符数组中
 默认输入回车表示输入结束
 放入数组中的字符数量取决于接受字符的最大个数n
和指定结束符

 系统提供的字符串处理函数定义在头文件<cstring>中


& ：取地址运算符
 *：间接引用运算符
 *p : 访问指针p所指向的内存的数据

允许声明void 类型的指针。该指针可以被赋予任何类型对象的地址。

& 取地址运算符 作用于内存中一个可寻址的数据（如变量，对象和数组元素等），操作结果是获得该数据的地址。
* 间接运算符 作用于一个指针变量，访问该指针所指向的内存变量

释放了point所指目标的内存空间，指针point本身并没有撤销。
 point 指针变成悬空指针，建议这时将point置空（NULL）。

１．用初始化式(initializer)来显式初始化
int *pi=new int(0);
２．当pi生命周期结束时，必须释放pi所指向的目标：
delete pi;
注意这时释放了pi所指的目标的内存空间，也就是撤销了该目标，称动态内存释放（dynamic memory deallocation），但指针pi本身并没有撤销，该指针所占内存空间并未释放
pi=NULL;

new和delete中的方括号必须配对使用。
 如果delete语句中少了方括号，因编译器认为该指针是指向数组第一个元素的指针，会产生回收不彻底的问题（只回收了第一个元素所占空间），加了方括号后就转化为指向数组的指针，回收整个数组。
 delete [ ]的方括号中不需要填数组元素数。
 创建时不能对数组元素进行初始化
 请注意“下标表达式“不要求常量表达式，即它的值不必在编译时确定，可以在运行时确定

选择排序
选择排序的基本思想：每一次从待排序的数组中选出值最小的元素，放在待排序子序列的第一个位置；
 在剩下的元素中继续上述操作，直到全部元素排序完成。
找出最小值的下标。
min=0;
for(i=1;i<=SIZE;i++)
if(arr[min]>arr[i])
min=i;
将最小元素与第一个元素交换
tmp=arr[0]; arr[0]=arr[min]; arr[min]=tmp;
8个元素的数组将上述过程循环8-1次即可，且每次将第一个元素排除在外。



函数声明、函数定义及函数调用
函数声明 
 意义
 在调用函数前先声明其返回值类型、函数名和参数
 函数原型有助于编译器对函数参数类型的匹配检查
 一个函数声明需要给三个关键部分：
 函数的名字
 函数返回值的类型
 调用这个函数时必须提供的参数个数和参数类型。

函数声明格式
数据类型 函数名(形参列表)；
形参列表：格式类似变量的定义，但每个形参必须给出独
立的类型说明。

函数返回值
函数的值只能通过return语句返回主调函数。
 return 语句的一般形式
return 表达式; 或 return (表达式);
功能：计算表达式的值，并返回给主调函数。
 在函数中允许有多个return语句（通常在条件语句中），但每次调用只能有一个return 语句被执行；
 当return语句执行时，结束函数的执行，返回到主调函数，其他return语句不会被执行。
函数的返回值应当属于某一个确定的类型
 在定义函数时指定函数返回值的类型

函数值的类型和函数定义中函数的类型应保持一致
 如果两者不一致以函数类型为准
 将返回值自动进行类型转换
 不返回函数值的函数，可以明确定义为空类型,类型说明符为 “void

函数定义
 指函数功能的确立
 指定函数名、函数类型、形参及类型、函数体等
 是完整独立的单位
 函数声明
 是对函数名、返回值类型、形参类型的说明
 不包括函数体
 是一条语句，以分号结束，只起一个声明作用

函数调用
函数名(表达式1, 表达式2, ……)
实际参数  函数调用时提供的表达式
有返回值时 
 放到一个数值表达式中 
c = max(a,b); 
 cout 输出流中调用函数 
cout<<max(a,b); 
 作为另一个函数调用的参数 
c = max(max(a, b),c);
无返回值时 
 函数调用表达式 
display(a,b);

函数设计的基本原则
入口参数有效性检查
敏感操作前的检查
调用成功与否的检查
1.函数规模要小
2.函数功能要单一
3.函数接口定义要清楚

变量按作用域范围分为两种，局部变量和全局变量局部变量也称为内部变量。局部变量是在函数内
或者块内{}定义说明的。其作用域仅限于函数内或者块内，离开该函数或块后再使用这种变量是非法的

全局变量
全局变量也称为外部变量，它是在函数体外定义的变量。全局变量属于整个源程序文件。其作用域是整个源程序。

例如：
int a, b; //在函数体外定义，全局变量
void fun1() //fun1函数定义
{……
}
double x, y; //全局变量
int fun2() // fun2函数定义
{……
}
int main() /*主函数*/
{……
}


 变量的生存期与变量的存储方式有关。从变量值存在的时间（即生存期）角度来分，可以分为静态存储方式和动态存储方式。
 静态存储方式：是指在程序运行期间分配固定的存储空间的方式。
 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。
 用户存储空间可以分为三个部分：
 1) 代码区；
 2) 静态存储区；
 3) 动态存储区


auto变量
函数中的局部变量，若未声明为static存储类别都属于auto变量，存储在动态存储区中。
 函数中的形参和在函数中定义的变量（包括在复合语句中定义的变量），都属auto变量
 在调用函数时系统会给它们分配存储空间，在函数调用结束时就自动释放这些存储空间。
 这类局部变量称为自动变量。自动变量用关键字auto作存储类别的声明，但常常省略。


static变量
在函数体内设置一个变量记录函数被调用的次数，这时就希望函数的这个局部变量在函数调用结束后不消失而继续保留原值。
 可以将该局部变量声明为static来解决问题。
 static变量分配在静态存储区，其生存期是属于整个程序的。
eg:static int count=0; //定义局部静态变量，初始值只会赋值一次

对静态局部变量的说明：
 1) 静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放。自动
变量（即动态局部变量）属于动态存储类别，占动态存储空间，函数调用结束后即释放。
 2) 静态局部变量在编译时赋初值，即只赋初值一次；而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。
 3) 如果在定义局部变量时不赋初值，则对静态局部变量来说，
编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。而对自动变量来说，如果不赋初值则它的值是一个不确定的值

用extern声明全局变量
如果全局变量在函数的外部定义
 作用域：从变量定义处开始，到本程序文件的末尾
如果外部变量不在文件的开头定义
 作用域：只限于定义处到文件末尾。
如果在定义点前的函数想引用该外部变量
 应该在引用之前用关键字extern对该变量作“外部变量声明”
 表示该变量是一个已经定义的外部变量。有此声明，就可以从“声明”处起，
合法地使用该外部变量
#include <iostream>
using namespace std;
int max(int x, int y);
int main()
{
extern A, B;
cout<<max(A,B)<<endl;
return 0;
}
int A=13, B=-8;
int max(int x, int y)
{
int z;
z=x>y?x:y;
return(z);
}


























































































































































